import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import sys

from scipy.stats import zscore

DEFAULT_ROLLING_WINDOW = 5


def sanitize_data(data, z_threshold=3):
    """
    Sanitizes the dataset by:
      - Removing rows with missing values for 'Time', 'Power', or 'FPS'.
      - Removing rows where FPS is non-positive (to prevent division by zero).
      - Removing rows where the 'Power' or 'FPS' columns have a z-score greater than the threshold.
    Note: The 'Time' column is not checked for outliers as it serves as the key.
    """
    initial_count = len(data)

    # Remove rows with missing values for the key columns
    data = data.dropna(subset=['Time', ' Power', ' FPS'])

    # Remove rows with non-positive FPS (to prevent division by zero)
    data = data[data[' FPS'] > 0]

    # Compute z-scores for 'Power' and 'FPS' only
    numeric_cols = [' Power', ' FPS']
    z_scores = np.abs(zscore(data[numeric_cols]))

    # Keep only rows where all z-scores are below the threshold
    data = data[(z_scores < z_threshold).all(axis=1)]

    final_count = len(data)

    if final_count < initial_count:
        print(f"Sanitized dataset: removed {initial_count - final_count} of {initial_count} rows.")

    return data


def match(title, rolling, path1, csv_data1, path2, csv_data2):

    # /!\ WARNING: in this code, we assume that the csv file has been generated by the JPFMonitoringPlugin
    # and that's why we expect columns power and fps to be preceded by a space.

    # Check that required columns exist
    required_columns = {"Time", " Power", " FPS"}

    if not required_columns.issubset(csv_data1.columns) or not required_columns.issubset(csv_data2.columns):
        print(f"One or more CSV file doesn't contains the columns: {required_columns}")
        return

    # Sanitize the data
    data1 = sanitize_data(csv_data1)
    data2 = sanitize_data(csv_data2)
    if data1.empty or data2.empty:
        print("No data left after sanitization. Please check the input CSV file.")
        return

    # Compute the ratio (Power / FPS)
    data1['Power_per_FPS'] = data1[' Power'] / data1[' FPS']
    data2['Power_per_FPS'] = data2[' Power'] / data2[' FPS']

    # Add the average of the Power_per_FPS column
    mean1 = data1['Power_per_FPS'].mean()
    for i in range(len(data1)):
        data1['Mean'] = mean1

    mean2 = data2['Power_per_FPS'].mean()
    for i in range(len(data2)):
        data2['Mean'] = mean2

    # Get the base filename without extension
    smoothed_str = "_smoothed" if draw_smoothed_only else ""
    output_filename = f"{title}_chart_rw{rolling_window}{smoothed_str}.png"


    # -------------------------
    # Create the plot
    # -------------------------

    # - Applying rolling window to smooth the data
    # Rolling window of 5, centered around each point
    data1['Smoothed'] = data1['Power_per_FPS'].rolling(window=rolling_window, center=True).mean()
    # Optionally, fill any NaN values created by the rolling at the edges
    data1['Smoothed'] = data1['Smoothed'].bfill().ffill()

    data2['Smoothed'] = data2['Power_per_FPS'].rolling(window=rolling_window, center=True).mean()
    # Optionally, fill any NaN values created by the rolling at the edges
    data2['Smoothed'] = data2['Smoothed'].bfill().ffill()

    # - Creating the plot
    plt.figure(figsize=(10, 6))
    # Plot both the original and the smoothed data for comparison
    if not draw_smoothed_only:
        plt.plot(data1['Time'], data1['Power_per_FPS'], label='Joule/Frame (Original)', linewidth=0.5, alpha=0.4, color="cyan")
    plt.plot(data1['Time'], data1['Smoothed'], label='Joule/Frame (Smoothed)', linewidth=1, color='blue')
    plt.plot(data1['Time'], data1['Mean'], label=f"Mean: {mean1:.2f}", linewidth=1, color='cyan')

    if not draw_smoothed_only:
        plt.plot(data2['Time'], data2['Power_per_FPS'], label='Joule/Frame (Original)', linewidth=0.5, alpha=0.4, color="pink")
    plt.plot(data2['Time'], data2['Smoothed'], label='Joule/Frame (Smoothed)', linewidth=1, color='purple')
    plt.plot(data2['Time'], data2['Mean'], label=f"Mean: {mean2:.2f}", linewidth=1, color='pink')
    # empty plot to add the rolling window size to the legend
    plt.plot([], [], ' ', label=f"Rolling Window: {rolling_window}")

    plt.xlabel('Time')
    plt.ylabel('Joule/Frame')
    plt.title(title)
    plt.legend()
    plt.grid(True)

    # Build the output path to the desktop (works on most systems)
    csv_directory = os.path.dirname(os.path.abspath(path1))
    output_path = os.path.join(csv_directory, output_filename)

    # Save the figure
    plt.savefig(output_path)
    print(f"Plot saved to {output_path}")


def print_usage():
    print("Usage: python plotter_matcher.py")
    print("The plotter_matcher.py script use a wizard so it doesn't need any arguments.")
    sys.exit(0)

def print_help():
    print("PlotterMatcher for JPFMonitoringPlugin is a tool to generate two curves from two csv files to allow the user to compare them. CSV files must contain the columns: Time, Power, FPS like the ones generated by the JPFMonitoringPlugin.")
    print_usage()


if __name__ == '__main__':

    # Check the command-line used to call the script
    if len(sys.argv) > 1:
        print_usage()
        sys.exit(1)

    # Wizard like questions to set up the script context

    rolling_window = int(input("Enter the rolling window size [5]: ").strip() or DEFAULT_ROLLING_WINDOW)
    draw_smoothed_only_input = input("Draw smoothed curves only (improve readability) ? [y/yes]: ").strip().lower() or "y"
    draw_smoothed_only = ["y", "yes"].count(draw_smoothed_only_input) > 0
    plot_title = input("Enter the title of the plot: ").strip()

    csv_path_1 = input("Enter the path to the first CSV file (will be blue): ").strip().strip("\"")
    try:
        csv_data_1 = pd.read_csv(csv_path_1)
    except Exception as e:
        print(f"Error reading the CSV file: {e}")
        sys.exit(1)

    csv_path_2 = input("Enter the path to the second CSV file (will be green): ").strip().strip("\"")
    try:
        csv_data_2 = pd.read_csv(csv_path_2)
    except Exception as e:
        print(f"Error reading the CSV file: {e}")
        sys.exit(1)

    match(plot_title, rolling_window, csv_path_1, csv_data_1, csv_path_2, csv_data_2)


