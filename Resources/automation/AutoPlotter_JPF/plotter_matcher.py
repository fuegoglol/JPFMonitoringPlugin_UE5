import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import sys

from scipy.stats import zscore

DEFAULT_ROLLING_WINDOW = 5


def sanitize_data(data, z_threshold=3):
    """
    Sanitizes the dataset by:
      - Removing rows with missing values for 'Time', 'Power', or 'FPS'.
      - Removing rows where FPS is non-positive (to prevent division by zero).
      - Removing rows where the 'Power' or 'FPS' columns have a z-score greater than the threshold.
    Note: The 'Time' column is not checked for outliers as it serves as the key.
    """
    initial_count = len(data)

    # Remove rows with missing values for the key columns
    if is_benchmark_mode:
        data = data.dropna(subset=['Time', 'MinJPF', 'AvgJPF', 'MaxJPF'])

        numeric_cols = ['MinJPF', 'AvgJPF', 'MaxJPF']
        z_scores = np.abs(zscore(data[numeric_cols]))

        # Keep only rows where all z-scores are below the threshold
        data = data[(z_scores < z_threshold).all(axis=1)]
    else:
        data = data.dropna(subset=['Time', ' Power', ' FPS'])
        # Remove rows with non-positive FPS (to prevent division by zero)
        data = data[data[' FPS'] > 0]

        numeric_cols = [' Power']

        # try to detect if FPS are at fixed value
        if data[' FPS'].nunique() == 1:
            print(f"Fixed FPS detected: {data[' FPS'].unique()[0]}")
        else:
            numeric_cols.append(' FPS')

        # Compute z-scores for 'Power' (and 'FPS' in case of varying FPS)
        z_scores = np.abs(zscore(data[numeric_cols]))

        # Keep only rows where all z-scores are below the threshold
        data = data[(z_scores < z_threshold).all(axis=1)]

    final_count = len(data)

    if final_count < initial_count:
        print(f"Sanitized dataset: removed {initial_count - final_count} of {initial_count} rows.")
    else:
        print("No rows removed during sanitization.")

    return data.reset_index(drop=True)


def match(title, rolling, path1, csv_data1, path2, csv_data2):

    # /!\ WARNING: in this code, we assume that the csv file has been generated by the JPFMonitoringPlugin
    # and that's why we expect columns power and fps to be preceded by a space.

    # Check that required columns exist
    required_columns = {"Time", " Power", " FPS"}

    if not required_columns.issubset(csv_data1.columns) or not required_columns.issubset(csv_data2.columns):
        print(f"One or more CSV file doesn't contains the columns: {required_columns}")
        return

    # Sanitize the data
    data1 = sanitize_data(csv_data1)
    data2 = sanitize_data(csv_data2)
    if data1.empty or data2.empty:
        print("No data left after sanitization. Please check the input CSV file.")
        return

    # Compute the ratio (Power / FPS)
    data1['Power_per_FPS'] = data1[' Power'] / data1[' FPS']
    data2['Power_per_FPS'] = data2[' Power'] / data2[' FPS']

    # Add the average of the Power_per_FPS column
    mean1 = data1['Power_per_FPS'].mean()
    for i in range(len(data1)):
        data1['Mean'] = mean1

    mean2 = data2['Power_per_FPS'].mean()
    for i in range(len(data2)):
        data2['Mean'] = mean2

    # Get the base filename without extension
    smoothed_str = "_smoothed" if draw_smoothed_only else ""
    output_filename = f"{title}_chart_rw{rolling}{smoothed_str}.png"


    # -------------------------
    # Create the plot
    # -------------------------

    # - Applying rolling window to smooth the data
    # Rolling window of 5, centered around each point
    data1['Smoothed'] = data1['Power_per_FPS'].rolling(window=rolling, center=True).mean()
    # Optionally, fill any NaN values created by the rolling at the edges
    data1['Smoothed'] = data1['Smoothed'].bfill().ffill()

    data2['Smoothed'] = data2['Power_per_FPS'].rolling(window=rolling, center=True).mean()
    # Optionally, fill any NaN values created by the rolling at the edges
    data2['Smoothed'] = data2['Smoothed'].bfill().ffill()

    # - Creating the plot
    plt.figure(figsize=(10, 6))
    # Plot both the original and the smoothed data for comparison
    if not draw_smoothed_only:
        plt.plot(data1['Time'], data1['Power_per_FPS'], label='Joule/Frame (Original)', linewidth=0.5, alpha=0.4, color="cyan")
        
    File1 = os.path.splitext(os.path.basename(path1))[0]
    
    plt.plot(data1['Time'], data1['Smoothed'], label=f"{File1} (Smoothed)", linewidth=1, color='blue')
    plt.plot(data1['Time'], data1['Mean'], label=f"Mean: {mean1:.2f}", linewidth=1, color='cyan')

    if not draw_smoothed_only:
        plt.plot(data2['Time'], data2['Power_per_FPS'], label='Joule/Frame (Original)', linewidth=0.5, alpha=0.4, color="pink")
        
    File2 = os.path.splitext(os.path.basename(path2))[0]
    
    plt.plot(data2['Time'], data2['Smoothed'], label=f"{File2} (Smoothed)", linewidth=1, color='purple')
    plt.plot(data2['Time'], data2['Mean'], label=f"Mean: {mean2:.2f}", linewidth=1, color='pink')
    # empty plot to add the rolling window size to the legend
    plt.plot([], [], ' ', label=f"Rolling Window: {rolling}")

    plt.xlabel('Time (s)')
    plt.ylabel('Joule/Frame')
    plt.title(title)
    plt.legend()
    plt.grid(True)

    # Build the output path to the desktop (works on most systems)
    csv_directory = os.path.dirname(os.path.abspath(path1))
    output_path = os.path.join(csv_directory, output_filename)

    # Save the figure
    plt.savefig(output_path)
    print(f"Plot saved to {output_path}")


def match_benchmark(title, rolling, path1, csv_data1, path2, csv_data2):
    # /!\ WARNING: in this code, we assume that the csv file has been generated by the JPFMonitoringPlugin
    # and that's why we expect columns power and fps to be preceded by a space.

    # Check that required columns exist
    required_columns = {"Time", "MinJPF", "AvgJPF", "MaxJPF"}

    if not required_columns.issubset(csv_data1.columns) or not required_columns.issubset(csv_data2.columns):
        print(f"One or more CSV file doesn't contains the columns: {required_columns}")
        return

    # Sanitize the data
    data1 = sanitize_data(csv_data1)
    data2 = sanitize_data(csv_data2)
    if data1.empty or data2.empty:
        print("No data left after sanitization. Please check the input CSV file.")
        return

    # Get the base filename without extension
    output_filename = f"{title}_benchmark_comp_chart_rw{rolling_window}.png"

    # -------------------------
    # Create the plot
    # -------------------------

    # - Applying rolling window to smooth the data
    # Rolling window of 5, centered around each point
    data1['minSmoothed'] = data1['MinJPF'].rolling(window=rolling_window, center=True).mean()
    data1['minSmoothed'] = data1['minSmoothed'].bfill().ffill()
    data1['avgSmoothed'] = data1['AvgJPF'].rolling(window=rolling_window, center=True).mean()
    data1['avgSmoothed'] = data1['avgSmoothed'].bfill().ffill()
    data1['maxSmoothed'] = data1['MaxJPF'].rolling(window=rolling_window, center=True).mean()
    data1['maxSmoothed'] = data1['maxSmoothed'].bfill().ffill()

    data2['minSmoothed'] = data2['MinJPF'].rolling(window=rolling_window, center=True).mean()
    data2['minSmoothed'] = data2['minSmoothed'].bfill().ffill()
    data2['avgSmoothed'] = data2['AvgJPF'].rolling(window=rolling_window, center=True).mean()
    data2['avgSmoothed'] = data2['avgSmoothed'].bfill().ffill()
    data2['maxSmoothed'] = data2['MaxJPF'].rolling(window=rolling_window, center=True).mean()
    data2['maxSmoothed'] = data2['maxSmoothed'].bfill().ffill()

    # - Creating the plot
    plt.figure(figsize=(10, 6))

    File1 = os.path.splitext(os.path.basename(path1))[0]

    plt.plot(data1['Time'], data1['minSmoothed'], label=f"min - {csv1_label}", linewidth=1, color='cyan')
    plt.plot(data1['Time'], data1['avgSmoothed'], label=f"avg - {csv1_label}", linewidth=1, color='lightblue')
    plt.plot(data1['Time'], data1['maxSmoothed'], label=f"max - {csv1_label}", linewidth=1, color='purple')

    File2 = os.path.splitext(os.path.basename(path2))[0]

    plt.plot(data2['Time'], data2['minSmoothed'], label=f"min - {csv2_label}", linewidth=1, color='pink')
    plt.plot(data2['Time'], data2['avgSmoothed'], label=f"avg - {csv2_label}", linewidth=1, color='orange')
    plt.plot(data2['Time'], data2['maxSmoothed'], label=f"max - {csv2_label}", linewidth=1, color='red')

    # empty plot to add the rolling window size to the legend
    plt.plot([], [], ' ', label=f"Rolling Window: {rolling_window}")

    plt.xlabel('Time (s)')
    plt.ylabel('Joule/Frame')
    plt.title(title)
    plt.legend()
    plt.grid(True)

    # Build the output path to the desktop (works on most systems)
    csv_directory = os.path.dirname(os.path.abspath(path1))
    output_path = os.path.join(csv_directory, output_filename)

    # Save the figure
    plt.savefig(output_path)
    print(f"Plot saved to {output_path}")

def print_usage():
    print("Usage: python plotter_matcher.py")
    print("The plotter_matcher.py script use a wizard so it doesn't need any arguments.")
    sys.exit(0)

def print_help():
    print("PlotterMatcher for JPFMonitoringPlugin is a tool to generate two curves from two csv files to allow the user to compare them. CSV files must contain the columns: Time, Power, FPS like the ones generated by the JPFMonitoringPlugin.")
    print_usage()


if __name__ == '__main__':

    # Check the command-line used to call the script
    if len(sys.argv) > 1:
        print_usage()
        sys.exit(1)

    # Wizard like questions to set up the script context

    is_benchmark_mode_input = input("Does matching CSV are benchmark csv? ? [n/no]: ").strip().lower() or "n"
    is_benchmark_mode = ["y", "yes"].count(is_benchmark_mode_input) > 0

    rolling_window = int(input("Enter the rolling window size [5]: ").strip() or DEFAULT_ROLLING_WINDOW)

    if not is_benchmark_mode:
        # Ask the user if they want to draw smoothed curves only (improve readability) if they are not in benchmark mode
        # Benchmark doesn't have the brut Power and FPS columns
        draw_smoothed_only_input = input("Draw smoothed curves only (improve readability) ? [y/yes]: ").strip().lower() or "y"
        draw_smoothed_only = ["y", "yes"].count(draw_smoothed_only_input) > 0

    plot_title = input("Enter the title of the plot: ").strip()

    csv_path_1 = input("Enter the path to the first CSV file (will be blue): ").strip().strip("\"")
    try:
        csv_data_1 = pd.read_csv(csv_path_1)
    except Exception as e:
        print(f"Error reading the CSV file: {e}")
        sys.exit(1)
    csv1_label = input("Enter the legend label for the first CSV file (max 15 characters): ").strip()
    # shortening the label to 15 characters
    if len(csv1_label) > 15:
        csv1_label = csv1_label[:15]


    csv_path_2 = input("Enter the path to the second CSV file (will be green): ").strip().strip("\"")
    try:
        csv_data_2 = pd.read_csv(csv_path_2)
    except Exception as e:
        print(f"Error reading the CSV file: {e}")
        sys.exit(1)
    csv2_label = input("Enter the legend label for the second CSV file (max 15 characters): ").strip()
    # shortening the label to 15 characters
    if len(csv2_label) > 15:
        csv2_label = csv2_label[:15]

    if is_benchmark_mode:
        match_benchmark(plot_title, rolling_window, csv_path_1, csv_data_1, csv_path_2, csv_data_2)
    else:
        match(plot_title, rolling_window, csv_path_1, csv_data_1, csv_path_2, csv_data_2)


